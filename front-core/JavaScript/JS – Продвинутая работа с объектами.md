## 1. Модель объекта

- Объект — ассоциативное хранилище пар ключ–значение + скрытая ссылка на прототип.
    
- Ключи:
    
    - `string` / `symbol` для обычных объектов
        
    - `number` приводится к string
        
- Доступ:
    
    - `obj.key` — статический, известный ключ
        
    - `obj[key]` — динамический, переменная или выражение
        

---

## 2. Прототипы и наследование

- У каждого объекта есть внутреннее свойство `[[Prototype]]`.
    
- Установка прототипа:
    
    - `Object.create(proto)` — предпочтительный способ
        
    - `Object.setPrototypeOf(obj, proto)` — медленнее, используется редко
        
- Поиск свойства:
    
    - Сначала в самом объекте
        
    - Если нет — по цепочке прототипов
        
- Проверка:
    
    - `obj.hasOwnProperty('key')` — только собственное свойство
        
    - `'key' in obj` — с учётом прототипов
        

---

## 3. Контекст `this`

- `this` определяется способом вызова, а не местом объявления:
    
    - Обычный вызов: `func()` — `this === undefined` в strict mode
        
    - Метод объекта: `obj.method()` — `this === obj`
        
    - В обработчике событий — DOM-элемент (в браузере)
        
- Жёсткая привязка контекста:
    
    - `func.bind(context)` — создаёт новую функцию с зафиксированным `this`
        
- В стрелочных функциях `this` не создаётся заново, берётся из внешней области.
    

---

## 4. Дескрипторы и флаги свойств

- Дескриптор описывает поведение свойства:
    
    - `value`, `writable`, `enumerable`, `configurable`
        
- Получение:
    
    ```js
    Object.getOwnPropertyDescriptor(obj, 'key')
    ```
    
- Создание/изменение:
    
    ```js
    Object.defineProperty(obj, 'key', {
      value: 1,
      writable: false,
      enumerable: true,
      configurable: false
    })
    ```
    
- Getter / setter:
    
    ```js
    Object.defineProperty(obj, 'fullName', {
      get() { return `${this.first} ${this.last}` },
      set(value) { [this.first, this.last] = value.split(' ') }
    })
    ```
    

---

## 5. Структурные операции с объектами

- Деструктуризация:
    
    ```js
    const { a, b: alias, c = 0, ...rest } = obj
    ```
    
- Слияние / копирование (поверхностное):
    
    ```js
    const clone = { ...obj }
    const merged = { ...a, ...b }
    ```
    
- Выделение части:
    
    ```js
    const { password, ...publicData } = user
    ```
    

---

## 6. Копирование и неизменяемость

- Поверхностная копия:
    
    - `Object.assign({}, obj)`
        
    - `{ ...obj }`
        
- Глубокая копия:
    
    - Через структурированный клон в средах, где доступен: `structuredClone(obj)`
        
    - Через ручной обход структуры или специализированные утилиты
        
- Защита объекта:
    
    - `Object.seal(obj)` — запрещает добавлять/удалять свойства
        
    - `Object.freeze(obj)` — запрещает изменять значения свойств
        

---

## 7. Перебор свойств

- Ключи только объекта:
    
    - `Object.keys(obj)` — имена
        
    - `Object.values(obj)` — значения
        
    - `Object.entries(obj)` — пары `[key, value]`
        
- Полный перебор по цепочке:
    
    - `for...in` — включает свойства из прототипов, требует фильтрации `hasOwnProperty`
        

---

## 8. Специализированные коллекции

- `Map`:
    
    - Ключи любого типа
        
    - Сохранение порядка вставки
        
- `Set`:
    
    - Уникальные значения
        
- `WeakMap` / `WeakSet`:
    
    - Ключи только объекты
        
    - Не мешают сборке мусора
        
    - Не перечисляются
        

