Оптимизация во Vue — это набор приёмов, которые уменьшают количество лишних рендеров, сокращают вычисления и избегают тяжёлых операций в реактивности. Правильная оптимизация повышает производительность интерфейса и снижает нагрузку на DOM.

**Минимизация реактивных данных**  
В реактивность помещаются только те значения, которые действительно участвуют в обновлении UI.  
Всё, что не должно триггерить ререндер, хранится вне `reactive`/`ref`.

```js
const config = { static: true } // не реагирует на изменения
```

**Использование вычисляемых значений вместо методов**  
`computed` кэшируется, `methods` вызываются каждый рендер.  
При дорогих вычислениях `computed` обязателен.

```js
const expensive = computed(() => heavy(data.value))
```

**Точечный `watch` вместо глобальных пересчётов**  
`watch` следует использовать для реакций на конкретные изменения, а не для логики рендера.  
`watchEffect` — когда нужна автоматическая реакция на все зависимости.

**Разделение компонентов**  
Мелкие компоненты уменьшают объём работы при обновлении.  
Vue обновляет только изменившиеся ветки дерева, поэтому дробление повышает эффективность.

**Контроль рендера через `v-once`, `v-memo`, `key`**

- `v-once` — зафиксировать элемент навсегда.
    
- `v-memo` — кешировать разметку, пока не изменится набор зависимостей.
    
- Правильные `key` позволяют корректно обновлять списки без лишних перерисовок.
    

**Оптимизация списков**  
Использовать `:key`, избегать сложных вычислений прямо внутри `v-for`, выносить подготовку данных в `computed`.

**Lazy loading компонентов**  
Динамический импорт:

```js
const AsyncComp = defineAsyncComponent(() => import('./Comp.vue'))
```

Снижает время первоначальной загрузки.

**Использование `shallowRef`, `shallowReactive` для больших структур**  
Полная реактивность тяжела для больших объектов и массивов.  
shallow-варианты отслеживают только верхний уровень.

**События, пересчёты и DOM**

- Не выполнять тяжёлую логику в обработчиках страниц и скроллов — использовать debounce/throttle.
    
- Не читать layout-свойства в больших циклах, чтобы избежать layout thrashing.
    

**Оптимизация шаблонов и логики рендера**  
Vue 3 имеет компилятор, который помечает статические узлы.  
Но слишком тяжёлые шаблоны можно облегчить:

- без вложенных вычислений,
    
- без сложных условий внутри цикла,
    
- без неконтролируемых ререндеров.
    

**Правильная работа со сторонними библиотеками**  
Все нереактивные ресурсы нужно хранить за пределами reactive, чтобы Vue не отслеживал лишние изменения:  
например, карты, графики, большие списки данных.

**Использование devtools и профилировщика**  
Vue Devtools показывает, какие компоненты рендерятся чаще остальных.  
Это ключевой инструмент поиска bottleneck'ов.

Оптимизация во Vue строится на принципе: чем меньше реактивности, ререндеров и лишних зависимостей — тем быстрее UI.