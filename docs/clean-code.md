# Чистый код

### Принципы

* **KISS** — упрощай решение до необходимого.
* **SRP** — один модуль/функция/компонент решает одну задачу.
* **DRY** — переиспользуй логику через функции, композицию, хуки.
* **YAGNI** — не реализуй то, что не нужно прямо сейчас.
* **Fail fast** — ранняя валидация входов и явные ошибки.
* **Контрактность** — чёткие интерфейсы, явные типы, предсказуемое API.

### Именование

* Переменные/функции — `camelCase`, компоненты — `PascalCase`, константы — `SCREAMING_SNAKE_CASE`.
* Имя отражает намерение: `getUser()` vs `process()`; булевы — `is/has/should`.
* Избегай аббревиатур и “магических” чисел (выноси в константы).

### Стиль и форматирование

* Единый автоформаттер (**Prettier**) и линтер (**ESLint**).
* Макс. длина строки 100–120 символов, пробелы вместо табов, одинарные кавычки.
* Один экспорт по умолчанию на файл или только именованные экспорты — выбери и придерживайся.
* Импорт: сначала внешние пакеты, затем алиасы, затем относительные; сортируй и группируй.

```json
// .prettierrc
{ "semi": false, "singleQuote": true, "printWidth": 100 }
```

```js
// .eslintrc.cjs (фрагмент)
module.exports = {
  extends: ['plugin:vue/vue3-recommended', '@vue/eslint-config-typescript', 'prettier'],
  rules: {
    'no-console': ['warn', { allow: ['warn', 'error'] }],
    'no-var': 'error',
    'prefer-const': 'error',
    '@typescript-eslint/consistent-type-imports': 'error'
  }
}
```

### JavaScript/TypeScript

* Включай строгий режим TS: `strict: true`, `noUncheckedIndexedAccess: true`.
* Сигнатуры функций максимума узкие, возвраты — явные. Предпочитай **ранние возвраты**.

```ts
function createUser(input: unknown) {
  if (!isValidUserInput(input)) return Result.err('invalid input')
  const dto = normalize(input)
  return Result.ok(dto)
}
```

* Не мутируй входы. Используй иммутабельные операции (`map`, `reduce`, спред).
* Типизируй данные снаружи: схемы `zod`/`valibot` для валидации API.

```ts
import { z } from 'zod'
export const User = z.object({ id: z.string().uuid(), email: z.string().email() })
export type User = z.infer<typeof User>
```

* Асинхронщина: `async/await`, **параллель** через `Promise.all`. Управляй отменой через `AbortController`.

```ts
const c = new AbortController()
fetch(url, { signal: c.signal })
c.abort()
```

* Ошибки: кидай **доменные** ошибки, логируй на границах, не подавляй исключения.

```ts
try {
  await service.pay(invoice)
} catch (e) {
  logger.error({ e }, 'payment failed')
  throw new PaymentError('PAYMENT_FAILED')
}
```

* Избегай `any`. Для узких мест — `unknown` + явная приведение/проверка.
* Юнит-логику держи чистой от побочек (I/O, DOM).

### Архитектура модулей

* **Файлы до 200–300 строк**, модули до 500–800; дроби при росте сложности.
* Публичный API папки — через `index.ts`, внутренние детали не реэкспортируй.
* Слои: `entities/`, `features/`, `widgets/`, `pages/`, `shared/` (вариант feature-sliced) или согласованный аналог.
* Границы зависят от домена: UI не знает о транспорта, только о портах/интерфейсах.

### Vue 3 (Composition API)

* Используй `<script setup>` и именованные файлы компонентов: `UserCard.vue`.
* **Пропсы/эмиты типизируй**:

```vue
<script setup lang="ts">
const props = defineProps<{ user: User; dense?: boolean }>()
const emit = defineEmits<{
  (e: 'select', id: string): void
}>()
</script>
```

* Логику выноси в `use*`-хуки (композиционные функции).
* `computed` вместо лишних `watch`, `watchEffect` — только для побочек.
* Избегай глубоких реактивных мутаций; используй `toRefs/readonly`.
* Слоты документируй через JSDoc в верхушке файла.
* Не храни в сторе то, что можно вывести из пропсов/роутера. Стор — источник правды для кросс-компонентного состояния.

```ts
// useFetch.ts
export function useFetch<T>(url: MaybeRef<string>) {
  const data = ref<T | null>(null)
  const error = ref<Error | null>(null)
  const loading = ref(false)
  const run = async () => { /* ... */ }
  onMounted(run)
  return { data, error, loading, run }
}
```

### Стили

* **BEM** либо **CSS Modules**/**Scoped** — единообразие важнее способа.
* В CSS-переменные выноси темы и токены дизайна: цвета, размеры, тени.
* Избегай глубоких селекторов `:deep` и каскада `!important`.
* Tailwind: утилитарные классы сгруппируй по смыслу, длинные наборы — в `@apply` компонентов.

```css
:root { --color-accent: #6366f1; }
.button { background: var(--color-accent); }
```

### Обработка ошибок и UX

* Пессимистичные сценарии покрывай явно: empty/error/loading состояния.
* Пользовательские тексты ошибок короткие, технические детали — в лог.
* Применяй **таймауты** и **повторы с джиттером** для сетевых вызовов.
* Не ломай навигацию ошибками — рендери fallback-и.

### Тесты

* Пирамида тестов: **юнит** (больше всего) → **интеграционные** → **e2e**.
* Тесты читаемы, AAA (Arrange–Act–Assert), без моков там, где можно обойтись фейками.
* Один сценарий — один ассерт-группа.

```ts
it('formats money', () => {
  expect(formatMoney(1234.5, 'RUB')).toBe('1 234,50 ₽')
})
```

### Документация и комментарии

* Документируй **публичные** функции/компоненты через TSDoc/JSDoc.
* Комментарии объясняют «почему», а не «что».
* ADR (Architecture Decision Record) на нетривиальные решения/компромиссы.

```ts
/**
 * Возвращает видимую пользователю метку цены.
 * @example formatMoney(1999.99, 'USD') -> "$1,999.99"
 */
export function formatMoney(/* ... */) {}
```

### Зависимости

* Отдавай предпочтение стандартным API и маленьким библиотекам.
* Следи за treeshaking (ESM), избегай динамических require.
* Не тащи «комбайн» ради одной функции — скопируй крошечный утил, если он стабилен.
* Пин `exact`-версии для критичных пакетов, аудит через `pnpm audit`/SCA.

### Производительность

* Измеряй, а не гадай: профилируй рендер, сетевые запросы и память.
* **Кэшируй** вычисления (`computed`, мемо), **дедуплицируй** запросы.
* Лениво загружай маршруты и тяжелые виджеты (`import()`), используйте `vite` code-splitting.
* Списки: виртуализация, ключи стабильны, избегай анонимных функций в рендере.
* Изображения: `srcset`, `sizes`, `loading="lazy"`, оптимизация форматов (AVIF/WebP).

### Доступность (a11y)

* Семантическая разметка, правильные роли и `aria-*`.
* Контраст, фокус-стили не отключать, клавиатурная навигация обязательна.
* Сообщения об ошибках форм — связаны с полями через `aria-describedby`.
* Анимации — с учетом `prefers-reduced-motion`.

### Безопасность в коде

* Не используй `v-html` и `innerHTML` без строго необходимой причины; при необходимости — `DOMPurify`.
* CSP-дружественный код: без инлайн-скриптов/стилей, без `eval`.
* Не логируй секреты и PII, маскируй чувствительные поля.
* Валидация входных данных на клиенте и на сервере (двойной контур).

### Git и ревью

* Маленькие PR (до 300 строк диффа), один смысл — один PR.
* Коммиты в стиле Conventional Commits: `feat:`, `fix:`, `refactor:`…
* В ревью проверяй: корректность, простоту, тесты, безопасность, перформанс, i18n, a11y.
* Не спорь без данных: ссылка на метрики/доки/issue.

### Анти-паттерны

* Глобальные синглтоны-состояния без явной причины.
* «Умные» компоненты, перегруженные ответственностями.
* Скрытые побочки в вычислениях и геттерах.
* Любая «магия» без тестов и документации.
* Комментарии вместо исправления плохого кода.

### Чек-лист приёма кода

* Имена и интерфейсы ясные, типы строгие.
* Нет дублирования: общая логика вынесена.
* Нет неиспользуемого кода/зависимостей.
* Тесты покрывают ключевые ветви и крайние случаи.
* Нет утечек памяти/подписок (`onUnmounted`/`finally`).
* Логи и ошибки осмысленные; нет `console.log`.
* Производительность приемлема: нет ненужных перерендеров, разбивка по чанкам есть.
* Доступность и i18n соблюдены.
* Безопасность: нет небезопасного HTML/URL, соблюдены политики.
