## Системный дизайн

### Цели и ограничения

* Ясные **SLA/SLO/SLI**: доступность (99.9%+), p95/p99 латентность, бюджет ошибок.
* Баланс **стоимости**, **надёжности** и **скорости разработки**.
* Базовые ограничения: входная нагрузка (RPS/QPS), пики, размер данных, география, регуляторика (PII/GDPR).

### Модель нагрузок и расчёты

* Пропускная способность: `throughput = RPS × avg_payload`.
* Емкость: `required_instances = ceil(peak_RPS / instance_RPS × safety_factor)`; safety ≈ 1.3–2.0.
* Очередь: при `λ > μ` растёт задержка (формула Эрланга/ММ1 для оценки).
* Хвостовые задержки: проектируй по **p95/p99**, а не по среднему.

### Архитектурные стили

* **Монолит**: быстро стартовать, просто деплоить; минусы — масштабирование по weakest link.
* **Микросервисы**: независимые деплои, масштабирование по доменам; минусы — сложность сети и согласованности.
* **Модульный монолит**: чёткие границы внутри одного деплоя — компромисс для средней стадии роста.

### Рендер и фронтенд-стратегии

* **SPA/CSR** для динамики, **SSR/SSG/ISR** для SEO/скорости первого контента.
* **Edge Rendering/Functions** для персонализации с низкой задержкой.
* **CDN**: статика с `immutable`, HTML — `stale-while-revalidate`.

### Балансировка и маршрутизация

* **L4/L7 балансировщики**: round-robin, least-connections, weighted.
* **Service Discovery**: DNS, Consul, Kubernetes.
* **Sticky-сессии** избегать; хранить сессию серверно (Redis) или stateless (JWT в cookie).

### Согласованность и устойчивость

* **CAP**: в сети с разделениями выбираем между C и A при сохранении P.
* **PACELC**: при разделений — C/A, иначе — латентность/согласованность.
* Паттерны: **idempotency**, **retry с экспоненциальным джиттером**, **circuit breaker**, **time-outs**, **bulkhead**.

### Данные и хранилища

* **Реляционные (PostgreSQL/MySQL)**: транзакции, связи, сложные запросы.
* **NoSQL**: Key-Value (Redis), Документные (MongoDB), Wide-Column (Cassandra), Графы (Neo4j).
* Выбор по Access Patterns: частота чтений/записей, размер документов, необходимость транзакций/джойнов.
* **Индексы**: проектировать по горячим запросам; следить за write amplification.
* **Нормализация vs денормализация**: OLTP → 3NF, OLAP/чтение → денормализация/материализованные представления.

### Партиционирование и репликация

* **Sharding**: по хешу (равномерно) или по диапазону (сканы/агрегаты).
* **Репликация**: leader–follower, multi-leader, quorum (Raft/Paxos).
* Чтение из реплик, запись на лидера; **read-after-write** через sticky к лидеру или версионирование.

### Кэширование

* Слои: **браузер → CDN → edge → app → DB**.
* Политики: **TTL**, **LRU/LFU**, **cache-aside**, **write-through**, **write-back**.
* Инвалидация: по ключам, по тегам, по событиям; избегать глобального purge.

### Очереди и события

* **Брокеры**: RabbitMQ (AMQP), Kafka (лог событий), SQS/PubSub.
* Паттерны: **event-driven**, **outbox/inbox** (гарантия доставки), **dead-letter**.
* Консьюмеры горизонтально масштабируются, idempotent-обработка обязательна.

### API и контракты

* **REST**: простота, кэшируемость, HATEOAS опционален.
* **GraphQL**: гибкая выборка, N+1 решается DataLoader/политиками.
* **gRPC**: бинарный протокол, быстрый, отлично для межсервисного взаимодействия.
* **SOAP/legacy**: только при необходимости совместимости.
* Контрактность: схемы (`OpenAPI/Proto/GraphQL SDL`), версионирование (URI/заголовки), deprecation-план.

### Безопасность

* **Аутентификация**: OAuth 2.1 / OIDC, PKCE; сессионность через httpOnly cookie.
* **Авторизация**: RBAC/ABAC, policy-as-code.
* **Защита транспорта**: TLS 1.3, HSTS, mTLS для межсервисного.
* **Secret management**: KMS/Secrets Manager, ротация ключей.
* **Boundary-валидаторы**: схемная валидация, ограничение размеров/скоростей (rate limiting, token bucket).
* **Изоляция**: CSP, CORS по allowlist, разделение доменов.

### Наблюдаемость

* **Логи**: структурированные (JSON), корреляция `trace_id/span_id`.
* **Метрики**: системные (CPU/RAM), бизнесовые (конверсия), SRE (SLI: latency, error rate, saturation).
* **Трейсинг**: OpenTelemetry, распределённые следы.
* **Алертинг**: SLO-бюджет ошибок, стратагемы alert fatigue.

### Доставка и эволюция

* **CI/CD**: проверка типов, тесты, SCA, build, security gates.
* **Релизы**: blue–green, canary, feature flags; database change management (expand–migrate–contract).
* **Rollback**: версионированные артефакты, миграции обратимы или shadow-путь.

### Тестовая стратегия

* **Юнит**: чистая бизнес-логика.
* **Интеграционные**: контракты API, стора, очередь.
* **E2E**: ключевые пользовательские пути.
* **Chaos/Load**: fault-injection (latency, packet loss), нагрузочное (stress, soak).

### Производительность

* **Горизонтальное масштабирование**: stateless-сервисы, sticky избегать.
* **Вертикальное**: профилирование, оптимизация GC/пула соединений.
* **Hot path**: профили по p99, избегай синхронной фан-аута (параллелизм с дедлайнами).
* **Backpressure**: очереди, семафоры, лимиты concurrency.

### Рассчёт емкости фронтенда

* CDN hit-ratio ≥ 90% для статики.
* HTML TTFB: edge/SSR ближе к пользователю; критический CSS inline, остальное — async.
* Бюджеты: JS ≤ 200–300KB gzip на critical path, LCP ≤ 2.5s, INP ≤ 200ms.

### Паттерны данных

* **CQRS**: разделение чтения/записи, проекции для чтения.
* **Event Sourcing**: журнал событий как источник истины; снимки для ускорения.
* **Sagas/процессы**: оркестрация длительных транзакций.

### Идемпотентность и согласованность

* Идемпотентные ключи (`Idempotency-Key`) для POST/PUT.
* Версионирование записей (`etag`, `if-match`) для оптимистичных блокировок.
* Повторы: экспоненциальная задержка + джиттер; лимит попыток; наблюдение DLQ.

### Типовые компоненты решения

* **API Gateway**: auth, rate limit, routing, observability.
* **BFF** (backend-for-frontend): агрегация для конкретных клиентов.
* **Auth Service**: токены, сессии, refresh, ревокация.
* **Billing/Payments**: вебхуки с подписью, идемпотентность, очередь.
* **Search**: отдельный индекс (OpenSearch/Algolia/Meilisearch).
* **Files/Media**: object storage + подписанные URL, трансформация на edge.

### Проектирование РБД (короткий чек-лист)

* Идентификаторы: `uuid v7`/snowflake; внешние ключи — явные.
* Времена: UTC, `created_at/updated_at`, аудит трассирует `actor`.
* Миграции: **избыточные** (expand), затем **переключение**, затем **очистка** (contract).
* Индексы: покрывающие, по селективности; избегать множественных `LIKE %...`.

### План инцидентов

* Обнаружение: алерты по ошибкам/латентности/сатурации.
* Диагностика: дашборды SLI, сэмплинг трейсов, журнал релизов/флагов.
* Митигирование: rate limit/feature off/circuit open/rollback.
* Постмортем: причины, уроки, действия (owner, дедлайны), без обвинений.

### Мини-кейс: каталог товаров (RPS 2k пиковый)

* **Frontend**: SSR на edge, CDN для статики, HTML `SWR=30s`.
* **API Gateway**: auth, кеширование `GET /products/:id` на 60s.
* **Сервисы**: `catalog`, `search`, `pricing`, `inventory`.
* **БД**: PostgreSQL (каталог, цены), Redis (кэш карточек), Search-индекс.
* **Очереди**: Kafka для событий обновления остатков/цен с outbox.
* **Кэш-стратегия**: cache-aside Redis, инвалидация по событиям.
* **Наблюдаемость**: p95 API ≤ 120ms, ошибка ≤ 0.1%, дашборды + алерты.
* **Надёжность**: два регионы active–active, репликации, бэкапы point-in-time.

### Документы и процессы

* **ADR** для значимых решений (контекст → варианты → выбор → последствия).
* **RACI**: роли и ответственность (кто согласует/делает/информируется).
* **Runbook**: операции (ротация ключей, масштабирование, восстановление).

### Чек-лист системного дизайна

1. Определены SLO/SLI, профили трафика и данные.
2. Ясные границы доменов, выбрана модель взаимодействия (sync/async).
3. Спроектированы схемы данных, индексы, стратегии миграций.
4. Кэширование и инвалидация описаны, TTL/политики задокументированы.
5. Идемпотентность, ретраи, timeouts, circuit breakers внедрены.
6. Наблюдаемость: логи, метрики, трейсинг, алерты по SLO.
7. Безопасность: authn/authz, шифрование, секреты, политика доступа.
8. План деградации/инцидентов: флаги, откат, запуск в пониженном режиме.
9. План capacity/затрат: масштабирование и лимиты, расчёт емкости.
10. Документация: ADR, схемы, runbooks, тестовые сценарии нагрузок.
