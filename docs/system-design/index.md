# Системный дизайн

### Цели и ограничения

* Ясные **SLA/SLO/SLI**: доступность (99.9%+), p95/p99 латентность, бюджет ошибок.
* Баланс **стоимости**, **надёжности** и **скорости разработки**.
* Базовые ограничения: входная нагрузка (RPS/QPS), пики, размер данных, география, регуляторика (PII/GDPR).

### Модель нагрузок и расчёты

* Пропускная способность: `throughput = RPS × avg_payload`.
* Емкость: `required_instances = ceil(peak_RPS / instance_RPS × safety_factor)`; safety ≈ 1.3–2.0.
* Очередь: при `λ > μ` растёт задержка (формула Эрланга/ММ1 для оценки).
* Хвостовые задержки: проектируй по **p95/p99**, а не по среднему.

### Архитектурные стили

* **Монолит**: быстро стартовать, просто деплоить; минусы — масштабирование по weakest link.
* **Микросервисы**: независимые деплои, масштабирование по доменам; минусы — сложность сети и согласованности.
* **Модульный монолит**: чёткие границы внутри одного деплоя — компромисс для средней стадии роста.

### Рендер и фронтенд-стратегии

* **SPA/CSR** для динамики, **SSR/SSG/ISR** для SEO/скорости первого контента.
* **Edge Rendering/Functions** для персонализации с низкой задержкой.
* **CDN**: статика с `immutable`, HTML — `stale-while-revalidate`.

### Балансировка и маршрутизация

* **L4/L7 балансировщики**: round-robin, least-connections, weighted.
* **Service Discovery**: DNS, Consul, Kubernetes.
* **Sticky-сессии** избегать; хранить сессию серверно (Redis) или stateless (JWT в cookie).

### Согласованность и устойчивость

* **CAP**: в сети с разделениями выбираем между C и A при сохранении P.
* **PACELC**: при разделений — C/A, иначе — латентность/согласованность.
* Паттерны: **idempotency**, **retry с экспоненциальным джиттером**, **circuit breaker**, **time-outs**, **bulkhead**.

### Данные и хранилища

* **Реляционные (PostgreSQL/MySQL)**: транзакции, связи, сложные запросы.
* **NoSQL**: Key-Value (Redis), Документные (MongoDB), Wide-Column (Cassandra), Графы (Neo4j).
* Выбор по Access Patterns: частота чтений/записей, размер документов, необходимость транзакций/джойнов.
* **Индексы**: проектировать по горячим запросам; следить за write amplification.
* **Нормализация vs денормализация**: OLTP → 3NF, OLAP/чтение → денормализация/материализованные представления.

### Партиционирование и репликация

* **Sharding**: по хешу (равномерно) или по диапазону (сканы/агрегаты).
* **Репликация**: leader–follower, multi-leader, quorum (Raft/Paxos).
* Чтение из реплик, запись на лидера; **read-after-write** через sticky к лидеру или версионирование.

### Кэширование

* Слои: **браузер → CDN → edge → app → DB**.
* Политики: **TTL**, **LRU/LFU**, **cache-aside**, **write-through**, **write-back**.
* Инвалидация: по ключам, по тегам, по событиям; избегать глобального purge.

### Очереди и события

* **Брокеры**: RabbitMQ (AMQP), Kafka (лог событий), SQS/PubSub.
* Паттерны: **event-driven**, **outbox/inbox** (гарантия доставки), **dead-letter**.
* Консьюмеры горизонтально масштабируются, idempotent-обработка обязательна.

### API и контракты

* **REST**: простота, кэшируемость, HATEOAS опционален.
* **GraphQL**: гибкая выборка, N+1 решается DataLoader/политиками.
* **gRPC**: бинарный протокол, быстрый, отлично для межсервисного взаимодействия.
* **SOAP/legacy**: только при необходимости совместимости.
* Контрактность: схемы (`OpenAPI/Proto/GraphQL SDL`), версионирование (URI/заголовки), deprecation-план.

### Безопасность

* **Аутентификация**: OAuth 2.1 / OIDC, PKCE; сессионность через httpOnly cookie.
* **Авторизация**: RBAC/ABAC, policy-as-code.
* **Защита транспорта**: TLS 1.3, HSTS, mTLS для межсервисного.
* **Secret management**: KMS/Secrets Manager, ротация ключей.
* **Boundary-валидаторы**: схемная валидация, ограничение размеров/скоростей (rate limiting, token bucket).
* **Изоляция**: CSP, CORS по allowlist, разделение доменов.

### Наблюдаемость

* **Логи**: структурированные (JSON), корреляция `trace_id/span_id`.
* **Метрики**: системные (CPU/RAM), бизнесовые (конверсия), SRE (SLI: latency, error rate, saturation).
* **Трейсинг**: OpenTelemetry, распределённые следы.
* **Алертинг**: SLO-бюджет ошибок, стратагемы alert fatigue.

### Доставка и эволюция

* **CI/CD**: проверка типов, тесты, SCA, build, security gates.
* **Релизы**: blue–green, canary, feature flags; database change management (expand–migrate–contract).
* **Rollback**: версионированные артефакты, миграции обратимы или shadow-путь.

### Тестовая стратегия

* **Юнит**: чистая бизнес-логика.
* **Интеграционные**: контракты API, стора, очередь.
* **E2E**: ключевые пользовательские пути.
* **Chaos/Load**: fault-injection (latency, packet loss), нагрузочное (stress, soak).

### Производительность

* **Горизонтальное масштабирование**: stateless-сервисы, sticky избегать.
* **Вертикальное**: профилирование, оптимизация GC/пула соединений.
* **Hot path**: профили по p99, избегай синхронной фан-аута (параллелизм с дедлайнами).
* **Backpressure**: очереди, семафоры, лимиты concurrency.

### Рассчёт емкости фронтенда

* CDN hit-ratio ≥ 90% для статики.
* HTML TTFB: edge/SSR ближе к пользователю; критический CSS inline, остальное — async.
* Бюджеты: JS ≤ 200–300KB gzip на critical path, LCP ≤ 2.5s, INP ≤ 200ms.

### Паттерны данных

* **CQRS**: разделение чтения/записи, проекции для чтения.
* **Event Sourcing**: журнал событий как источник истины; снимки для ускорения.
* **Sagas/процессы**: оркестрация длительных транзакций.

### Идемпотентность и согласованность

* Идемпотентные ключи (`Idempotency-Key`) для POST/PUT.
* Версионирование записей (`etag`, `if-match`) для оптимистичных блокировок.
* Повторы: экспоненциальная задержка + джиттер; лимит попыток; наблюдение DLQ.

### Типовые компоненты решения

* **API Gateway**: auth, rate limit, routing, observability.
* **BFF** (backend-for-frontend): агрегация для конкретных клиентов.
* **Auth Service**: токены, сессии, refresh, ревокация.
* **Billing/Payments**: вебхуки с подписью, идемпотентность, очередь.
* **Search**: отдельный индекс (OpenSearch/Algolia/Meilisearch).
* **Files/Media**: object storage + подписанные URL, трансформация на edge.

### Проектирование РБД (короткий чек-лист)

* Идентификаторы: `uuid v7`/snowflake; внешние ключи — явные.
* Времена: UTC, `created_at/updated_at`, аудит трассирует `actor`.
* Миграции: **избыточные** (expand), затем **переключение**, затем **очистка** (contract).
* Индексы: покрывающие, по селективности; избегать множественных `LIKE %...`.

### План инцидентов

* Обнаружение: алерты по ошибкам/латентности/сатурации.
* Диагностика: дашборды SLI, сэмплинг трейсов, журнал релизов/флагов.
* Митигирование: rate limit/feature off/circuit open/rollback.
* Постмортем: причины, уроки, действия (owner, дедлайны), без обвинений.

### Мини-кейс: каталог товаров (RPS 2k пиковый)

* **Frontend**: SSR на edge, CDN для статики, HTML `SWR=30s`.
* **API Gateway**: auth, кеширование `GET /products/:id` на 60s.
* **Сервисы**: `catalog`, `search`, `pricing`, `inventory`.
* **БД**: PostgreSQL (каталог, цены), Redis (кэш карточек), Search-индекс.
* **Очереди**: Kafka для событий обновления остатков/цен с outbox.
* **Кэш-стратегия**: cache-aside Redis, инвалидация по событиям.
* **Наблюдаемость**: p95 API ≤ 120ms, ошибка ≤ 0.1%, дашборды + алерты.
* **Надёжность**: два регионы active–active, репликации, бэкапы point-in-time.

### Документы и процессы

* **ADR** для значимых решений (контекст → варианты → выбор → последствия).
* **RACI**: роли и ответственность (кто согласует/делает/информируется).
* **Runbook**: операции (ротация ключей, масштабирование, восстановление).

### Чек-лист системного дизайна

1. Определены SLO/SLI, профили трафика и данные.
2. Ясные границы доменов, выбрана модель взаимодействия (sync/async).
3. Спроектированы схемы данных, индексы, стратегии миграций.
4. Кэширование и инвалидация описаны, TTL/политики задокументированы.
5. Идемпотентность, ретраи, timeouts, circuit breakers внедрены.
6. Наблюдаемость: логи, метрики, трейсинг, алерты по SLO.
7. Безопасность: authn/authz, шифрование, секреты, политика доступа.
8. План деградации/инцидентов: флаги, откат, запуск в пониженном режиме.
9. План capacity/затрат: масштабирование и лимиты, расчёт емкости.
10. Документация: ADR, схемы, runbooks, тестовые сценарии нагрузок.

<h2 id="principles">KISS (Keep It Simple, Stupid) </h2>

**Суть:** простые решения работают лучше сложных. Чем меньше слоёв абстракции и побочных эффектов, тем легче
поддерживать и расширять систему.

**Основная идея:**
Код должен быть очевидным для любого разработчика, читающего его впервые. Простота не означает примитивность — она
требует ясной архитектуры, минимализма и осознанного отказа от избыточных оптимизаций.

**Рекомендации:**

* Не усложняй алгоритмы без необходимости.
* Избегай "гибкости наперёд" — добавляй абстракции, когда они действительно нужны.
* Пиши код, который легко объяснить словами.
* Убирай дублирование логики и бесполезные уровни вложенности.
* Простое решение, которое работает, всегда предпочтительнее идеального, но непонятного.

**Пример:**

```ts
// Плохо
function fetchDataAndProcess(url: string, handler: (data: any) => void) {
    fetch(url)
        .then(response => response.json())
        .then(data => {
            const result = handler(data)
            console.log('Processed:', result)
            return result
        })
        .catch(err => console.error('Error:', err))
}

// Лучше
async function fetchData(url: string) {
    const res = await fetch(url)
    return res.json()
}
```

## DRY (Don’t Repeat Yourself)

**Суть:** избегай дублирования логики, данных и поведения.

**Основная идея:**
Каждый фрагмент знания должен иметь единственное, недвусмысленное представление в системе. Повторение приводит к
рассинхронизации, ошибкам и сложностям при изменениях.

**Рекомендации:**

* Выноси повторяющиеся конструкции в функции, компоненты, утилиты.
* Используй общие типы и интерфейсы в TypeScript.
* Не дублируй данные в разных слоях — синхронизируй через источник истины (single source of truth).
* Следи, чтобы переиспользование не превращалось в чрезмерную обобщённость.

**Пример:**

```ts
// Плохо: одинаковая логика форматирования
function formatPrice(price: number) {
    return `${price.toFixed(2)} ₽`
}

function formatTotal(sum: number) {
    return `${sum.toFixed(2)} ₽`
}

// Лучше: общая функция
function formatCurrency(value: number, currency = '₽') {
    return `${value.toFixed(2)} ${currency}`
}
```

**Баланс:**
Не стоит превращать DRY в догму. Избыточная "унификация" может привести к тесной связности и усложнению кода. Иногда
проще повторить небольшую часть логики, чем создавать слишком абстрактный слой.

## SOLID

Набор из пяти принципов объектно-ориентированного проектирования, направленных на устойчивость и расширяемость кода.

### S — Single Responsibility Principle (Принцип единственной ответственности)

Класс или модуль должен иметь одну чётко определённую задачу.
Изменение бизнес-логики должно затрагивать минимальное количество модулей.

```ts
// Плохо: класс делает всё сразу
class UserService {
    saveUser(user: User) { /* ... */
    }

    sendWelcomeEmail(user: User) { /* ... */
    }
}

// Лучше: разделение ответственности
class UserRepository {
    save(user: User) { /* ... */
    }
}

class UserNotifier {
    sendWelcomeEmail(user: User) { /* ... */
    }
}
```

### O — Open/Closed Principle (Открыт для расширения, закрыт для модификации)

Поведение системы должно расширяться без изменения уже проверенного кода.

```ts
// Плохо: добавление новых типов ломает старый код
function calculateArea(shape: any) {
    if (shape.type === 'circle') return Math.PI * shape.r ** 2
    if (shape.type === 'square') return shape.size ** 2
}

// Лучше: полиморфизм
interface Shape {
    area(): number
}

class Circle implements Shape {
    constructor(private r: number) {
    }

    area() {
        return Math.PI * this.r ** 2
    }
}

class Square implements Shape {
    constructor(private size: number) {
    }

    area() {
        return this.size ** 2
    }
}
```

### L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)

Объекты подклассов должны корректно заменять объекты базового класса без нарушения поведения программы.

```ts
// Плохо: подкласс нарушает контракт
class Bird {
    fly() {
    }
}

class Penguin extends Bird {
    fly() {
        throw new Error("Penguins can't fly")
    }
}

// Лучше: корректная иерархия
class Bird {
}

class FlyingBird extends Bird {
    fly() {
    }
}

class Penguin extends Bird {
}
```

### I — Interface Segregation Principle (Принцип разделения интерфейсов)

Интерфейсы не должны заставлять реализовывать лишние методы.

```ts
// Плохо
interface Worker {
    work(): void

    eat(): void
}

class Robot implements Worker {
    work() {
    }

    eat() {
    } // не имеет смысла
}

// Лучше
interface Workable {
    work(): void
}

interface Eatable {
    eat(): void
}

class Human implements Workable, Eatable {
    work() {
    }

    eat() {
    }
}

class Robot implements Workable {
    work() {
    }
}
```

### D — Dependency Inversion Principle (Принцип инверсии зависимостей)

Модули верхнего уровня не должны зависеть от деталей нижнего уровня. Оба должны зависеть от абстракций.

```ts
// Плохо
class ApiService {
    constructor(private db: MySQLDatabase) {
    }

    getData() {
        return this.db.query('SELECT * FROM data')
    }
}

// Лучше
interface Database {
    query(sql: string): any
}

class MySQLDatabase implements Database {
    query(sql: string) { /* ... */
    }
}

class ApiService {
    constructor(private db: Database) {
    }

    getData() {
        return this.db.query('SELECT * FROM data')
    }
}
```

## Итоговое сравнение

| Принцип   | Цель                         | Ключевая мысль                                  |
|-----------|------------------------------|-------------------------------------------------|
| **KISS**  | Простота                     | Избегай ненужной сложности                      |
| **DRY**   | Минимизация дублирования     | Одна истина для каждого знания                  |
| **SOLID** | Расширяемость и устойчивость | Делай код гибким, изолированным и предсказуемым |

Применение этих принципов в совокупности создаёт код, который проще поддерживать, тестировать и развивать в долгосрочной
перспективе.



