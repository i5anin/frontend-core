## Протоколы обмена данными

### Общая идея

Протокол обмена данными определяет формат и правила взаимодействия между клиентом и сервером или между микросервисами.
Главная цель — **взаимопонимание систем**, независимо от языка, платформы и архитектуры.
Ключевые свойства: **формат сериализации**, **способ доставки**, **гарантии доставки**, **договор (контракт)**.

---

## REST (Representational State Transfer)

### Особенности

* Текстовый протокол поверх **HTTP**.
* Взаимодействие через **ресурсы** (URL) и **глаголы HTTP** (`GET`, `POST`, `PUT`, `PATCH`, `DELETE`).
* Данные обычно в **JSON** или **XML**.
* Без состояния (**stateless**): каждый запрос содержит всю информацию для обработки.

### Пример

```http
GET /api/users/123
Accept: application/json
```

Ответ:

```json
{
  "id": 123,
  "name": "Alice",
  "email": "alice@example.com"
}
```

### Преимущества

* Простота и читаемость.
* Кэширование на уровне HTTP.
* Широкая поддержка во всех клиентах.

### Недостатки

* Избыточность при сложных запросах (overfetch/underfetch).
* Версионирование через URI или заголовки.
* Нет строгого контракта, часто требуется OpenAPI/Swagger.

---

## GraphQL

### Особенности

* Клиент описывает **точно**, какие данные ему нужны.
* Один эндпоинт (`/graphql`), запросы в формате декларативных схем.
* Типизация через **SDL (Schema Definition Language)**.
* Передача по HTTP POST, JSON.

### Пример запроса

```graphql
query {
  user(id: 123) {
    id
    name
    posts(limit: 2) {
      title
      createdAt
    }
  }
}
```

Ответ:

```json
{
  "data": {
    "user": {
      "id": 123,
      "name": "Alice",
      "posts": [{ "title": "First", "createdAt": "2025-10-01" }]
    }
  }
}
```

### Преимущества

* Нет избыточных данных.
* Типобезопасность (GraphQL Schema).
* Возможность объединять несколько источников данных.

### Недостатки

* Сложность кэширования.
* Тяжелые запросы могут перегружать сервер.
* Без строгой rate-limit политики может стать уязвимым.

---

## gRPC

### Особенности

* Основан на **HTTP/2** и **Protocol Buffers (protobuf)**.
* Строгая типизация, бинарный формат, высокая производительность.
* Поддерживает **streaming** (однонаправленный и двунаправленный).
* Хорошо подходит для межсервисного взаимодействия (Backend-to-Backend).

### Пример контракта (`.proto`)

```proto
syntax = "proto3";

service UserService {
  rpc GetUser (UserRequest) returns (UserResponse);
}

message UserRequest { int32 id = 1; }
message UserResponse { int32 id = 1; string name = 2; string email = 3; }
```

### Пример вызова

```ts
const client = new UserServiceClient('https://api.example.com')
const res = await client.getUser({ id: 123 })
console.log(res.name)
```

### Преимущества

* Очень быстрый и компактный.
* Генерация кода из контракта (stub).
* Поддерживает стриминг и bidirectional связи.

### Недостатки

* Не человекочитаемый формат.
* Проблемы с кэшированием через HTTP-прокси.
* Неудобен для браузеров без gRPC-Web.

---

## SOAP (Simple Object Access Protocol)

### Особенности

* Старый стандарт, XML-базирующийся.
* Передача через HTTP, SMTP и другие протоколы.
* Контракт строго определяется через **WSDL**.
* Используется в enterprise-системах и государственных API.

### Пример запроса

```xml
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:urn="urn:UserService">
  <soapenv:Body>
    <urn:GetUser>
      <urn:id>123</urn:id>
    </urn:GetUser>
  </soapenv:Body>
</soapenv:Envelope>
```

### Преимущества

* Жёсткая типизация и контракты (WSDL).
* Поддержка сложных транзакций и безопасности (WS-Security).

### Недостатки

* XML-шум и высокая избыточность.
* Медленный и тяжеловесный по сравнению с REST/gRPC.

---

## WebSocket

### Особенности

* Двусторонний канал поверх TCP.
* Поддерживает постоянное соединение (реактивный обмен).
* Используется для чатов, нотификаций, стримов.

### Пример

```js
const socket = new WebSocket('wss://example.com/socket')
socket.onmessage = (e) => console.log('Received:', e.data)
socket.send(JSON.stringify({ type: 'ping' }))
```

### Преимущества

* Низкая задержка, постоянное соединение.
* Подходит для real-time сценариев.

### Недостатки

* Сложнее масштабировать (нужен stateful backend).
* Нет стандартных схем валидации и версионирования.

---

## Server-Sent Events (SSE)

* Односторонний стрим от сервера к клиенту.
* Поверх HTTP, автоматический reconnect.
* Используется для обновлений и real-time метрик.

```js
const sse = new EventSource('/events')
sse.onmessage = e => console.log(e.data)
```

---

## MQTT

* Легковесный publish/subscribe протокол поверх TCP.
* Популярен в IoT и embedded-системах.
* Передаёт бинарные payload, поддерживает QoS уровни (0,1,2).

---

## AMQP (RabbitMQ)

* Брокер сообщений, обмен событиями и командами между сервисами.
* Поддерживает маршрутизацию (`exchange`, `queue`, `routing key`), подтверждения и очереди DLQ.
* Гарантии доставки: At-most-once / At-least-once / Exactly-once (через idempotency).

---

## JSON-RPC / XML-RPC

* Минимальные протоколы удалённого вызова процедур.
* Простые и кроссплатформенные, но без гибкости GraphQL/gRPC.

```json
{ "jsonrpc": "2.0", "method": "getUser", "params": { "id": 123 }, "id": 1 }
```

---

## Форматы данных

| Формат      | Особенности                      | Применение      |
| ----------- | -------------------------------- | --------------- |
| JSON        | текстовый, человекочитаемый      | REST, GraphQL   |
| XML         | строгая схема, валидация XSD     | SOAP, legacy    |
| Protobuf    | бинарный, компактный             | gRPC            |
| Avro        | бинарный, самоописание схемы     | Kafka, Hadoop   |
| MessagePack | бинарный JSON-аналог             | мобильные и IoT |
| YAML        | человекочитаемый, но небезопасен | конфигурации    |

---

## Выбор протокола по контексту

| Сценарий                    | Протокол     | Формат          |
| --------------------------- | ------------ | --------------- |
| Публичное API               | REST         | JSON            |
| Микросервисы                | gRPC / AMQP  | Protobuf        |
| Реалтайм-чаты / уведомления | WebSocket    | JSON / MsgPack  |
| Большие потоки данных       | Kafka / MQTT | Avro / Protobuf |
| Сложная аналитика и фильтры | GraphQL      | JSON            |
| Государственные интеграции  | SOAP         | XML             |

---

## Контракты и документация

* **OpenAPI / Swagger** — спецификация REST API.
* **GraphQL SDL** — схема типов и запросов.
* **.proto** — контракт gRPC.
* **AsyncAPI** — описание событийных API.
* **JSON Schema** — валидация данных.

---

## Практические принципы проектирования API

1. Контракт — единственный источник истины (сначала схема, потом реализация).
2. Строгая типизация входов и выходов.
3. Версионирование: `v1`, `v2`, `Accept: application/vnd.api+json;version=2`.
4. Идемпотентность POST/PUT через `Idempotency-Key`.
5. Ограничение скорости: `X-Rate-Limit`, `Retry-After`.
6. Кэширование (ETag, Last-Modified).
7. Валидация и сериализация на границах.
8. Логирование запросов и метрик (latency, status, payload size).

---

## Чек-лист по протоколам

* Формат данных стандартизован и версионирован.
* Контракты документированы (OpenAPI/Proto/SDL).
* Обеспечены таймауты и ретраи.
* Поддерживается идемпотентность.
* Для асинхронных сценариев применён брокер событий.
* API имеет метрики: RPS, p95 latency, error rate.

---

Современные системы часто комбинируют несколько протоколов: REST для внешнего API, gRPC между сервисами, GraphQL для UI-агрегации, а Kafka/AMQP — для событий. Такой гибридный подход объединяет **простоту, строгость и производительность**, обеспечивая согласованность всей архитектуры данных.
