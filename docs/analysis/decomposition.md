## Декомпозиция задач

### Определение

**Декомпозиция** — это процесс разбиения сложной задачи на более мелкие, управляемые и измеримые части.
Она нужна, чтобы сделать задачу **понятной**, **оценимой** и **выполнимой** в рамках итерации.
Главная цель — превратить «сделать модуль аутентификации» в конкретные шаги, которые можно планировать, проверять и завершать.

---

## Принципы декомпозиции

1. **Одна задача — один результат.**
   Каждый тикет должен давать конкретный, проверяемый артефакт: компонент, API, фича, тест.

2. **Сверху вниз.**
   Сначала формулируется цель → потом подсистемы → потом конкретные подзадачи.

3. **Минимальная единица — до 1–2 дней работы.**
   Всё, что длиннее — надо разбивать.

4. **Зависимости видимы.**
   Задачи должны иметь ясный порядок: что блокирует что.

5. **Проверяемость.**
   Каждая подзадача должна иметь понятный критерий готовности (**Definition of Done**).

---

## Подход к декомпозиции

### 1. Цель → Функциональные блоки

Пример: «Сделать страницу входа».
Функциональные блоки:

* верстка формы;
* валидация полей;
* запрос к API;
* обработка ошибок;
* редирект после входа.

### 2. Технические подзадачи

* Создать компонент `LoginForm.vue`.
* Подключить Pinia для состояния пользователя.
* Написать сервис `authService.login()`.
* Реализовать router-guard для защищённых маршрутов.
* Написать unit-тесты и e2e-сценарий.

---

## Уровни декомпозиции

| Уровень       | Что включает                    | Пример                     |
| ------------- | ------------------------------- | -------------------------- |
| **Эпик**      | Крупная бизнес-фича             | «Система аутентификации»   |
| **Фича**      | Функциональный модуль           | «Страница входа»           |
| **Задача**    | Реализация части функционала    | «Добавить валидацию формы» |
| **Подзадача** | Конкретное техническое действие | «Проверить email по regex» |

---

## Методы декомпозиции

### 1. По слоям архитектуры

* **Frontend / Backend / DB / Infra / QA**.
* Удобно для микросервисов и комплексных релизов.

### 2. По пользовательскому сценарию

* Разделение по шагам взаимодействия (UX flow).
* Пример: регистрация → подтверждение email → вход → профиль.

### 3. По жизненному циклу разработки

* Анализ → Проектирование → Реализация → Тестирование → Релиз.

### 4. По типу работы

* Функционал
* UI/UX
* API
* Тесты
* Документация
* Оптимизация

---

## Пример: декомпозиция фичи "Личный кабинет пользователя"

**Эпик:** личный кабинет.
**Фичи:**

1. Профиль пользователя
2. Настройки безопасности
3. История заказов

**Декомпозиция "Профиль пользователя":**

* [Frontend] Страница `/profile`
* [Backend] Endpoint `GET /api/user/profile`
* [Backend] Endpoint `PATCH /api/user/profile`
* [Frontend] Компонент `ProfileForm.vue`
* [Frontend] Валидация форм
* [QA] Тест сценария изменения данных

Каждый тикет — самостоятельный, проверяемый, не требует знаний всего контекста.

---

## Приёмы и рекомендации

### Чек-лист перед декомпозицией

* Цель понятна?
* Есть критерий готовности (DoD)?
* Подзадачи независимы?
* Можно тестировать каждую часть отдельно?
* Есть чёткие связи и приоритеты?

### Хорошие практики

* Используй **вербальные глаголы**: “Добавить”, “Реализовать”, “Обновить”, “Удалить”.
* Пиши **описание результата**, не процесса.

  > ❌ «Сделать логику формы»
  > ✅ «Добавить валидацию полей email и пароля при сабмите формы».
* В каждой задаче — **ожидаемый результат**, **критерий приёмки**, **ссылки на дизайн/доки**.
* Объединяй только логически связанные изменения (1 PR = 1 смысл).

---

## Визуальная декомпозиция

### Mind Map

Подходит для поиска структуры задачи.
Пример:

```
Профиль пользователя
 ├── UI
 │    ├── Аватар
 │    ├── Поля формы
 │    └── Кнопка "Сохранить"
 ├── API
 │    ├── GET /user
 │    ├── PATCH /user
 └── Валидация
      ├── Обязательные поля
      ├── Email формат
      └── Длина пароля
```

### User Story Mapping

Фокус на пользовательском пути:

```
Как пользователь → Хочу обновить профиль → Чтобы сохранить актуальные данные
```

→ Разделить на шаги: открыть страницу → изменить данные → сохранить → увидеть подтверждение.

---

## Антипаттерны

1. **Огромные задачи**: нельзя завершить за итерацию.
2. **Неясные формулировки**: непонятно, что именно делать.
3. **Пересекающиеся задачи**: несколько людей меняют один и тот же файл.
4. **Отсутствие критериев приёмки**: нельзя проверить результат.
5. **Декомпозиция по “коммитам”** — не отражает ценность для продукта.

---

## Инструменты

* **Jira / YouTrack / Linear / Notion** — структурирование задач.
* **PlantUML / Excalidraw / Miro** — визуальные карты.
* **ADR (Architecture Decision Record)** — документирование решений.
* **GitLab Issues / MR templates** — стандартизация описаний.

---

## Пример шаблона задачи

**Заголовок:** Добавить валидацию email и пароля в форме входа
**Описание:**
Реализовать клиентскую валидацию для `LoginForm.vue`

* Проверка email через regex
* Минимальная длина пароля — 8 символов
* Сообщения об ошибках на русском

**Критерии приёмки:**

* Некорректный email вызывает ошибку
* Кнопка disabled, если форма невалидна
* Тесты покрывают оба сценария

---

## Чек-лист хорошей декомпозиции

1. Каждая подзадача имеет один измеримый результат.
2. Зависимости минимальны и задокументированы.
3. Все шаги логически выстроены.
4. Подзадачи независимы по исполнителю.
5. В сумме — реализуют полную бизнес-функцию.
6. Каждая задача ≤ 1–2 дня.
7. Есть критерий готовности и тест.
8. Все решения и контекст зафиксированы в тикете.

---

Хорошая декомпозиция — это не бюрократия, а **инструмент прозрачности**.
Она делает проект управляемым, задачи — предсказуемыми, а команду — синхронной.
Если задача декомпозирована правильно, её можно взять, сделать и не задавать уточняющих вопросов.
