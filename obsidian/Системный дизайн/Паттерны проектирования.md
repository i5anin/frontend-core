

**1. Понимание групп паттернов**  
Знание деления на порождающие, структурные, поведенческие — must have.

---

**2. Умение объяснять назначение каждого паттерна**  
Коротко и по делу, например:  
`Strategy` — изоляция алгоритмов и переключение без изменения клиента.  
`Observer` — реакция на событие без прямой зависимости.  
`Factory` — контроль создания объектов.  
`Facade` — упрощённый интерфейс поверх сложной системы.

---

**3. Применимость и контекст**  
Главный критерий собеса — понимаешь ли ты, _когда_ паттерн нужен.  
Например:

- Когда использовать `Decorator` вместо наследования.
    
- Когда `Command` даёт преимущество перед прямым вызовом.
    
- Когда `State` упрощает кучу `if/else`.
    
- Когда `Adapter` позволяет интегрировать несовместимый интерфейс.
    

---

**4. Умение решить практическую задачу паттерном**  
Типовые задания:

- «Есть разные способы оплаты. Как расширять без переписывания?» → `Strategy`.
    
- «Нужно уведомлять несколько модулей о событии» → `Observer`.
    
- «Нужно сохранить состояние и откатить» → `Memento`.
    
- «Сложная подсистема, нужен простой API» → `Facade`.
    
- «Объект меняет поведение по состоянию» → `State`.
    

---

**5. Умение показать кодовые структуры (ES2025)**  
Например, `Strategy` на JS/Vue backend/frontend:  
Объект-хранилище стратегий, интерфейс, выбор стратегии по ключу.

---

**6. Что реально спрашивают на собесе**

- Чем `Strategy` отличается от `State`.
    
- Чем `Decorator` отличается от `Proxy`.
    
- Как распознать необходимость паттерна в реальном коде.
    
- Плюсы/минусы `Singleton` (и почему его почти всегда избегают).
    
- Как соединяются паттерны между собой.
    
- Где в твоём опыте паттерн решал проблему.
    
