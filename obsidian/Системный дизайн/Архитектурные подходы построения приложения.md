### `Monolith`

- Одна кодовая база, одно приложение, одна схема БД.
    
- Общий деплой: вся система выкатывается целиком.
    
- Тесная связность модулей.
    
- Подходит для: `MVP`, малых и средних проектов, быстрых изменений.
    
- Проблемы: рост сложности, трудно масштабировать отдельные части, риск «большого шара грязи».
    

---

### `Modular monolith`

- `Monolith`, разделённый на независимые доменные модули.
    
- Жёсткие границы между модулями: собственные слои, интерфейсы, контракты.
    
- Один деплой, но внутренняя архитектура близка к распределённой.
    
- Подходит для: проектов, где в будущем возможен переход к `microservices`.
    
- Требование: строгая дисциплина зависимостей.
    

---

### `Microservices`

- Система из множества независимых сервисов.
    
- Каждый сервис: свой код, свои данные (`own database per service` желательно).
    
- Взаимодействие через `HTTP`, `gRPC`, `message broker`.
    
- Подходит для: крупных систем, разных доменов, высокой нагрузки.
    
- Проблемы: сложность распределённых транзакций, мониторинга, трассировки, деплоя.
    

---

### `Event-driven`

- Взаимодействие через события (`event bus`, `message broker`).
    
- Сервисы реагируют на события, а не вызывают друг друга напрямую.
    
- Ослабление связности, возможность асинхронных процессов.
    
- Подходит для: сложных бизнес-процессов, интеграций, построения `audit log`.
    
- Требует чёткого дизайна событий и идемпотентности обработчиков.
    

---

### `Layered architecture` (слойная)

- Классические слои: `UI` → `Application` → `Domain` → `Infrastructure`.
    
- Вверх зависимости не идут, только вниз.
    
- Логика домена изолирована от деталей (`DB`, `HTTP`, `FS`).
    
- Подходит как базовый паттерн для `monolith` и `modular monolith`.
    

---

### `Hexagonal` (Ports & Adapters)

- Ядро (`Domain`) не зависит от внешнего мира.
    
- Взаимодействие через `ports` (интерфейсы) и `adapters` (реализации).
    
- Лёгкая замена `DB`, `API`, интерфейсов без изменения домена.
    
- Подходит для: долгоживущих систем, где важна тестируемость и изоляция домена.
    

---

### `Clean / Onion` архитектуры

- В центре — `domain` и бизнес-правила.
    
- Внешние слои: интерфейсы, инфраструктура, адаптеры.
    
- Зависимости направлены только внутрь, к домену.
    
- Усиливают принципы `SOLID`, облегчают unit-тестирование.
    

---

### Сравнение подходов (упрощённо)

|Подход|Гранулярность|Сложность реализации|Деплой|Связность|Масштаб проекта|
|---|---|---|---|---|---|
|`Monolith`|крупная|низкая|единый|высокая|малый/средний|
|`Modular monolith`|средняя|средняя|единый|средняя|средний/крупный|
|`Microservices`|мелкая|высокая|множественный|низкая|крупный/enterprise|
|`Event-driven`|зависит от сервиса|высокая|распределённый|низкая по контрактам|сложные БП, интеграции|
|`Layered`|логические слои|средняя|зависит от формы|средняя|универсально|
|`Hexagonal/Clean/Onion`|логика/домены|высокая|любая|низкая (через порты)|долгосрочные системы|