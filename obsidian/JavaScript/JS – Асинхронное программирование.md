Асинхронность в JavaScript основана на неблокирующей модели выполнения и работе событийного цикла.

### 1. Механизм исполнения

JavaScript однопоточен. Асинхронность достигается через:

- **Event Loop** — управляет выполнением задач.
    
- **Call Stack** — стек текущих вызовов.
    
- **Callback Queue / Microtask Queue** — очереди задач.
    

Приоритет: **microtasks → macrotasks**.

### 2. Основные примитивы

**Callback**  
Функция передаётся как аргумент и вызывается позже. Используется для таймеров, событий, файловых операций (в среде Node.js).  
Минус: вложенность и сложность контроля ошибок.

**Promise**  
Объект состояния асинхронной операции: _pending_, _fulfilled_, _rejected_.  
Методы: `.then`, `.catch`, `.finally`.  
Разрубают вложенность, дают управляемость цепочек.

**async/await**  
Синтаксическая надстройка над Promise.  
`await` останавливает выполнение внутри функции до выполнения Promise, не блокируя главный поток.

### 3. Типы очередей

- **microtasks** — Promise callbacks, queueMicrotask
    
- **macrotasks** — setTimeout, setInterval, I/O, события
    

Правило: microtasks выполняются перед переходом к следующей macrotask.

### 4. Работа с сетью

Асинхронные операции: `fetch`, WebSocket, File API, Streams.  
Все сетевые операции возвращают Promise (fetch) или события.

### 5. Ошибки и обработка

В async/await обязательна обработка исключений:

```js
try {
    await task()
} catch (e) {
    // обработка
}
```

### 6. Критические ошибки в понимании

- setTimeout(0) не выполняется сразу — это macrotask.
    
- async/await не делает код синхронным — поток не блокируется.
    
- Promise не «хранят данные», а управляют состоянием операции.
    
- Асинхронность не равна многопоточности.
    

---

Если требуется — подготовлю расширенную инструкцию или вопросы для проверки глубины знаний.