### Цель `hotfix`

- Срочное исправление критической ошибки в `production` без ожидания полного релиза.
    
- Минимальный объём изменений, жёсткий контроль области влияния.
    
- Обязательная синхронизация с основными ветками (`trunk`, `develop`).
    

---

### Требования к `hotfix`

- Только критические проблемы: падения, потеря данных, блокирующие баги.
    
- Запрет рефакторинга, фич и “заодно поправил”.
    
- Полная трассируемость: `issue` → `branch` → `MR` → `tag`.
    

---

### Стратегия ветвления

Базовая модель (`trunk + release + hotfix`):

- Основная ветка: `main` / `trunk`.
    
- Релизная ветка: `release/x.y.0`.
    
- `hotfix`-ветка: `hotfix/x.y.z-<short-name>`.
    

Пример имени ветки:

- `hotfix/1.4.3-payment-timeout`
    
- `hotfix/2.1.1-auth-token-expiry`
    

---

### Семантика версий `semver` для `hotfix`

- `MAJOR.MINOR.PATCH`
    
- `hotfix` повышает только `PATCH`:
    
    - Было: `1.4.2`
        
    - Стало: `1.4.3` (`hotfix`)
        

`tag` для релиза:

- `v1.4.3`
    
- Описание `tag` содержит ссылку на `issue` и `MR`.
    

---

### Процесс формирования `hotfix`

1. **Выбор базы:**
    
    - Если баг в текущем релизе: ветка от `tag` или `release/x.y.0`.
        
    - Если несколько релизных линий: отдельный `hotfix` для каждой поддерживаемой версии.
        
2. **Создание ветки:**
    
    ```bash
    git checkout -b hotfix/1.4.3-payment-timeout v1.4.2
    ```
    
3. **Минимальный фикс:**
    
    - Вносится только код, directly связанный с багом.
        
    - Любые “улучшения” — в отдельную задачу, не в `hotfix`.
        
4. **Пайплайн проверки:**
    
    - Запуск `GitLab CI`: `lint`, `unit`, `integration`, `e2e` (если есть быстрые).
        
    - Пайплайн `hotfix` должен быть максимально строгим.
        
5. **`Merge Request` в релизную ветку:**
    
    - Цель: `release/x.y.0` или отдельная ветка `hotfix-release/1.4.3`.
        
    - Требуется минимум 1–2 апрува (`Maintainer`/`Owner`).
        
6. **Сборка и деплой:**
    
    - Отдельный `job` в `.gitlab-ci.yml` для `hotfix`-релизов.
        
    - Деплой на `staging` / `preprod`, smoke-тесты.
        
    - После подтверждения — деплой в `production`.
        
7. **Создание `tag` и релиза:**
    
    ```bash
    git tag -a v1.4.3 -m "Hotfix: payment timeout"
    git push origin v1.4.3
    ```
    
    - Автоматический запуск релизного пайплайна по `tag`.
        
8. **Обратное слияние (back-merge):**
    
    - `hotfix`-изменения обязаны уйти в:
        
        - `main` / `trunk`
            
        - `develop` (если есть)
            
    - Запрещено держать фикс только в релизной ветке.
        

---

### Специфика `GitLab` при `hotfix`

- Отдельный `stage` в `.gitlab-ci.yml` для `hotfix`:
    
    - Ограниченный набор `job` (только критичные проверки, быстрые).
        
    - Отдельная логика деплоя по `tag` вида `v*.patch`.
        

Пример фрагмента `.gitlab-ci.yml`:

```yaml
stages:
  - test
  - build
  - deploy

hotfix_test:
  stage: test
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^hotfix\//'
  script:
    - npm ci
    - npm run test:critical

hotfix_deploy_prod:
  stage: deploy
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
  script:
    - ./deploy.sh prod
  environment:
    name: production
```

---

### Политики и защита

- `hotfix`-ветки защищаются политикой:
    
    - MR-only, запрет `push` напрямую в `release` / `main`.
        
    - Требование `pipeline must succeed`.
        
    - Обязательные `reviewers` / `code owners` для критичных областей (`payments`, `auth`).
        
- Логирование:
    
    - Каждому `hotfix` соответствует `issue` с типом `incident` или `bug`.
        
    - Все ссылки (`issue` ↔ `MR` ↔ `tag`) должны быть связаны.
        

---

### Типичные ошибки формирования `hotfix`

- Ветка делается от `develop`, а не от релиза → в `prod` уезжают незавершённые фичи.
    
- В `hotfix` попадает рефакторинг, форматирование, лишние изменения.
    
- Фикс попал в `release`, но не слит обратно в `main` / `develop` → регресс в будущем релизе.
    
- Ручной деплой без фиксации в `tag` → невозможно восстановить точную версию кода.